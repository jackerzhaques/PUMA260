//Standard includes
#include <stdbool.h>
#include <stdint.h>

//Project includes
#include "pinout.h"
#include "EIB/SPI.h"

//Tivaware includes
#include "inc/hw_memmap.h"
#include "driverlib/gpio.h"
#include "driverlib/rom.h"
#include "driverlib/sysctl.h"
#include "driverlib/pin_map.h"
#include "driverlib/pwm.h"
#include "driverlib/adc.h"
#include "driverlib/ssi.h"
#include "driverlib/uart.h"
#include "utils/uartstdio.h"


void EnableClock(void);
void EnablePeripherals(void);
void InitConsole(void);

int main(void)
{
    EnableClock();
    EnablePeripherals();

    UARTprintf("PUMA260 Robot\n");
    UARTprintf("Hardware Initialized\n");

    //Slave select channel 0
    GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_1, 0);
    GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_2, 0);
    GPIOPinWrite(GPIO_PORTH_BASE, GPIO_PIN_0, 0);

    //Chip deselect
    GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_7, 0);
    SysCtlDelay(SysCtlClockGet() / 10);

    while(1){
        uint8_t MDR0 = 0;

        //Chip select
        GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_7, GPIO_PIN_7);
        SPI_Write(0x88);//Write MDR0 opcode
        SPI_Write(0x80 | 0x00 | 0x00 | 0x03);//Filter 2, No Index, Free run, x4 Quadrature Count mode
        GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_7, 0);

        //Read MDR0 back
        GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_7, GPIO_PIN_7);
        SPI_Write(0x48);//Read MDR0 Opcode
        MDR0 = SPI_Read();//Should be 0x83
        GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_7, 0);
    }

#if 0

    //Enable PWM for PF1 (M0)
    //Set the PWM clock
    SysCtlPWMClockSet(SYSCTL_PWMDIV_1);

    //Enable the PWM peripheral and wait
    SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM0);

    //Enable GPIO Port F
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);

    //Wait for the clock to stabilize
    SysCtlDelay(1);

    //Conifgure PWM0 to count up/down without synchronization
    PWMGenConfigure(PWM0_BASE, PWM_GEN_0, PWM_GEN_MODE_UP_DOWN | PWM_GEN_MODE_NO_SYNC);
    //PWMGenConfigure(PWM0_BASE, PWM_GEN_2, PWM_GEN_MODE_UP_DOWN | PWM_GEN_MODE_NO_SYNC);
    //PWMGenConfigure(PWM0_BASE, PWM_GEN_3, PWM_GEN_MODE_UP_DOWN | PWM_GEN_MODE_NO_SYNC);

    //Set the PWM frequency to 250Hz
    //N = (1 / f) * SysClk, where N is the function parameter and f is the frequency
    PWMGenPeriodSet(PWM0_BASE, PWM_GEN_0, 64000);
    //PWMGenPeriodSet(PWM0_BASE, PWM_GEN_2, 64000);
    //PWMGenPeriodSet(PWM0_BASE, PWM_GEN_3, 64000);

    //Set the duty cycle to 25%
    //Duty cycle is a function of the period, use PWMGenPeriodGet()
    //For a frequency of 25%, Calculation is N * 25%
    PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, PWMGenPeriodGet(PWM0_BASE, PWM_GEN_0) / 4);
    //PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, PWMGenPeriodGet(PWM0_BASE, PWM_GEN_2) / 4);
    //PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, PWMGenPeriodGet(PWM0_BASE, PWM_GEN_2) / 4);
    //PWMPulseWidthSet(PWM0_BASE, PWM_OUT_4, PWMGenPeriodGet(PWM0_BASE, PWM_GEN_3) / 4);

    //Enable the PWM Bit3(PF3) signal
    PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, true);

    //Enable the PWM generator block
    PWMGenEnable(PWM0_BASE, PWM_GEN_0);

    while(1)
    {
        uint32_t ui32ReceivedEncoderTicks;

#ifdef TEST_MOTORS
        //Disengage the brake
        GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_4, GPIO_PIN_4);
        GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_3, GPIO_PIN_3);
#endif

#ifdef TEST_GPIO_OUTPUT
        /*
         * Encoder Interface Board Low
         */
        //EIB Slave Select Low
        GPIOPinWrite(GPIO_PORTH_BASE, GPIO_PIN_0, 0);   //SS2
        GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_1, 0);   //SS0
        GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_2, 0);   //SS1
        GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_7, 0);   //SS Clk

        //EIB DFLAG Low
        GPIOPinWrite(GPIO_PORTK_BASE, GPIO_PIN_5, 0);   //DFLAG CLK

        //EIB LED
        GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_0, 0);

        /*
         * Encoder Interface Board High
         */

        //EIB Slave Select High
        GPIOPinWrite(GPIO_PORTH_BASE, GPIO_PIN_0, GPIO_PIN_0);
        GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_1, GPIO_PIN_1);
        GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_2, GPIO_PIN_2);
        GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_7, GPIO_PIN_7);

        //EIB DFLAG High
        GPIOPinWrite(GPIO_PORTK_BASE, GPIO_PIN_5, GPIO_PIN_5);   //DFLAG CLK

        //EIB LED
        GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_0, GPIO_PIN_0);
#endif
    }
#endif
}

void EnableInvert(void);

void EnableClock(void){
    //Run the PLL at 120MHz
    SysCtlClockFreqSet((SYSCTL_XTAL_25MHZ |
                      SYSCTL_OSC_MAIN |
                      SYSCTL_USE_PLL |
                      SYSCTL_CFG_VCO_480), 120000000);
}

/*
    Enables all peripherals needed for this motor driver test
*/
void EnablePeripherals(void){
    //Use the pinout code generated by TI PinMux.

    //Enable the SPI Peripheral and wait for the clock to settle
    SysCtlPeripheralEnable(SYSCTL_PERIPH_SSI3);

    InitConsole();
    PinoutSet();
    SPI_Initialize();
}

//Initializes UART0 to be used as a console.
void InitConsole(void){
    //
    // Enable GPIO port A which is used for UART0 pins.
    // TODO: change this to whichever GPIO port you are using.
    //
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);

    //
    // Configure the pin muxing for UART0 functions on port A0 and A1.
    // This step is not necessary if your part does not support pin muxing.
    // TODO: change this to select the port/pin you are using.
    //
    GPIOPinConfigure(GPIO_PA0_U0RX);
    GPIOPinConfigure(GPIO_PA1_U0TX);

    //
    // Enable UART0 so that we can configure the clock.
    //
    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);

    //
    // Use the internal 16MHz oscillator as the UART clock source.
    //
    UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);

    //
    // Select the alternate (UART) function for these pins.
    // TODO: change this to select the port/pin you are using.
    //
    GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);

    //
    // Initialize the UART for console I/O.
    //
    UARTStdioConfig(0, 115200, 16000000);
}
